{"ast":null,"code":"/** @license React vundefined\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n    var allFamiliesByID = new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap();\n    var updatedFamiliesByType = new PossiblyWeakMap();\n    var pendingUpdates = [];\n    var helpersByRendererID = new Map();\n    var helpersByRoot = new Map();\n    var mountedRoots = new Set();\n    var failedRoots = new Map();\n    var didSomeRootFailOnMount = false;\n\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n\n      var fullKey = signature.ownKey;\n      var hooks;\n\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n\n        if (typeof hook !== 'function') {\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n\n        var nestedHookSignature = allSignaturesByType.get(hook);\n\n        if (nestedHookSignature === undefined) {\n          continue;\n        }\n\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n\n        fullKey += '\\n---\\n' + nestedHookKey;\n      }\n\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n\n      if (prevSignature === undefined && nextSignature === undefined) {\n        return true;\n      }\n\n      if (prevSignature === undefined || nextSignature === undefined) {\n        return false;\n      }\n\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n\n      if (nextSignature.forceReset) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolveFamily(type) {\n      return updatedFamiliesByType.get(type);\n    }\n\n    function performReactRefresh() {\n      {\n        if (pendingUpdates.length === 0) {\n          return null;\n        }\n\n        var staleFamilies = new Set();\n        var updatedFamilies = new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function (_ref) {\n          var family = _ref[0],\n              nextType = _ref[1];\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType;\n\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        });\n        var update = {\n          updatedFamilies: updatedFamilies,\n          staleFamilies: staleFamilies\n        };\n        helpersByRendererID.forEach(function (helpers) {\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null;\n        failedRoots.forEach(function (element, root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n\n        if (didError) {\n          throw firstError;\n        }\n\n        return update;\n      }\n    }\n\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n\n        if (typeof type !== 'function' && typeof type !== 'object') {\n          return;\n        }\n\n        if (allFamiliesByType.has(type)) {\n          return;\n        }\n\n        var family = allFamiliesByID.get(id);\n\n        if (family === undefined) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n\n        allFamiliesByType.set(type, family);\n\n        if (typeof type === 'object' && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + '$render');\n              break;\n\n            case REACT_MEMO_TYPE:\n              register(type.type, id + '$type');\n              break;\n          }\n        }\n      }\n    }\n\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n      {\n        allSignaturesByType.set(type, {\n          forceReset: forceReset,\n          ownKey: key,\n          fullKey: null,\n          getCustomHooks: getCustomHooks || function () {\n            return [];\n          }\n        });\n      }\n    }\n\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n\n        if (signature !== undefined) {\n          computeFullKey(signature);\n        }\n      }\n    }\n\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = new Set();\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function (inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n\n    function injectIntoGlobalHook(globalObject) {\n      {\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n        if (hook === undefined) {\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            supportsFiber: true,\n            inject: function inject(injected) {\n              return nextID++;\n            },\n            onCommitFiberRoot: function onCommitFiberRoot(id, root, maybePriorityLevel, didError) {},\n            onCommitFiberUnmount: function onCommitFiberUnmount() {}\n          };\n        }\n\n        var oldInject = hook.inject;\n\n        hook.inject = function (injected) {\n          var id = oldInject.apply(this, arguments);\n\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            helpersByRendererID.set(id, injected);\n          }\n\n          return id;\n        };\n\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n\n          if (helpers === undefined) {\n            return;\n          }\n\n          helpersByRoot.set(root, helpers);\n          var current = root.current;\n          var alternate = current.alternate;\n\n          if (alternate !== null) {\n            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n            var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n            if (!wasMounted && isMounted) {\n              mountedRoots.add(root);\n              failedRoots.delete(root);\n            } else if (wasMounted && isMounted) {} else if (wasMounted && !isMounted) {\n              mountedRoots.delete(root);\n\n              if (didError) {\n                failedRoots.set(root, alternate.memoizedState.element);\n              } else {\n                helpersByRoot.delete(root);\n              }\n            } else if (!wasMounted && !isMounted) {\n              if (didError && !failedRoots.has(root)) {\n                didSomeRootFailOnMount = true;\n              }\n            }\n          } else {\n            mountedRoots.add(root);\n          }\n\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n\n    function hasUnrecoverableErrors() {\n      return didSomeRootFailOnMount;\n    }\n\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    }\n\n    function createSignatureFunctionForTransform() {\n      {\n        var status = 'needsSignature';\n        var savedType;\n        var hasCustomHooks;\n        return function (type, key, forceReset, getCustomHooks) {\n          switch (status) {\n            case 'needsSignature':\n              if (type !== undefined) {\n                savedType = type;\n                hasCustomHooks = typeof getCustomHooks === 'function';\n                setSignature(type, key, forceReset, getCustomHooks);\n                status = 'needsCustomHooks';\n              }\n\n              break;\n\n            case 'needsCustomHooks':\n              if (hasCustomHooks) {\n                collectCustomHooksForSignature(savedType);\n              }\n\n              status = 'resolved';\n              break;\n\n            case 'resolved':\n              break;\n          }\n\n          return type;\n        };\n      }\n    }\n\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case 'function':\n            {\n              if (type.prototype != null) {\n                if (type.prototype.isReactComponent) {\n                  return true;\n                }\n\n                var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n                  return false;\n                }\n\n                if (type.prototype.__proto__ !== Object.prototype) {\n                  return false;\n                }\n              }\n\n              var name = type.name || type.displayName;\n              return typeof name === 'string' && /^[A-Z]/.test(name);\n            }\n\n          case 'object':\n            {\n              if (type != null) {\n                switch (type.$$typeof) {\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_MEMO_TYPE:\n                    return true;\n\n                  default:\n                    return false;\n                }\n              }\n\n              return false;\n            }\n\n          default:\n            {\n              return false;\n            }\n        }\n      }\n    }\n\n    var ReactFreshRuntime = Object.freeze({\n      performReactRefresh: performReactRefresh,\n      register: register,\n      setSignature: setSignature,\n      collectCustomHooksForSignature: collectCustomHooksForSignature,\n      getFamilyByID: getFamilyByID,\n      getFamilyByType: getFamilyByType,\n      findAffectedHostInstances: findAffectedHostInstances,\n      injectIntoGlobalHook: injectIntoGlobalHook,\n      hasUnrecoverableErrors: hasUnrecoverableErrors,\n      _getMountedRootCount: _getMountedRootCount,\n      createSignatureFunctionForTransform: createSignatureFunctionForTransform,\n      isLikelyComponentType: isLikelyComponentType\n    });\n    var runtime = ReactFreshRuntime.default || ReactFreshRuntime;\n    module.exports = runtime;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","hasSymbol","Symbol","for","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","PossiblyWeakMap","WeakMap","Map","allFamiliesByID","allFamiliesByType","allSignaturesByType","updatedFamiliesByType","pendingUpdates","helpersByRendererID","helpersByRoot","mountedRoots","Set","failedRoots","didSomeRootFailOnMount","computeFullKey","signature","fullKey","ownKey","hooks","getCustomHooks","err","forceReset","i","length","hook","nestedHookSignature","get","undefined","nestedHookKey","haveEqualSignatures","prevType","nextType","prevSignature","nextSignature","isReactClass","type","prototype","isReactComponent","canPreserveStateBetween","resolveFamily","performReactRefresh","staleFamilies","updatedFamilies","updates","forEach","_ref","family","current","set","add","update","helpers","setRefreshHandler","didError","firstError","element","root","Error","scheduleRoot","scheduleRefresh","register","id","has","push","$$typeof","render","setSignature","key","arguments","collectCustomHooksForSignature","getFamilyByID","getFamilyByType","findAffectedHostInstances","families","affectedInstances","instancesForRoot","findHostInstancesForRefresh","inst","injectIntoGlobalHook","globalObject","__REACT_DEVTOOLS_GLOBAL_HOOK__","nextID","supportsFiber","inject","injected","onCommitFiberRoot","maybePriorityLevel","onCommitFiberUnmount","oldInject","apply","oldOnCommitFiberRoot","alternate","wasMounted","memoizedState","isMounted","delete","hasUnrecoverableErrors","_getMountedRootCount","size","createSignatureFunctionForTransform","status","savedType","hasCustomHooks","isLikelyComponentType","ownNames","Object","getOwnPropertyNames","__proto__","name","displayName","test","ReactFreshRuntime","freeze","runtime","default","module","exports"],"sources":["/Users/mac/Developer/ReactNative/dessertReactNativeApp/node_modules/react-refresh/cjs/react-refresh-runtime.development.js"],"sourcesContent":["/** @license React vundefined\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\n\n\n\n\n\n // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\n\n\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n\n\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\n\nvar allFamiliesByID = new Map();\nvar allFamiliesByType = new PossiblyWeakMap();\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\n// $FlowIssue\n\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\n\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\nvar helpersByRendererID = new Map();\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\nvar mountedRoots = new Set(); // If a root captures an error, we add its element to this Map so we can retry on edit.\n\nvar failedRoots = new Map();\nvar didSomeRootFailOnMount = false;\n\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n\n  var fullKey = signature.ownKey;\n  var hooks;\n\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n\n  for (var i = 0; i < hooks.length; i++) {\n    var hook = hooks[i];\n\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    var nestedHookSignature = allSignaturesByType.get(hook);\n\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue;\n    }\n\n    var nestedHookKey = computeFullKey(nestedHookSignature);\n\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  signature.fullKey = fullKey;\n  return fullKey;\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  var prevSignature = allSignaturesByType.get(prevType);\n  var nextSignature = allSignaturesByType.get(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n\n  if (nextSignature.forceReset) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type);\n}\n\nfunction performReactRefresh() {\n  {\n    if (pendingUpdates.length === 0) {\n      return null;\n    }\n\n    var staleFamilies = new Set();\n    var updatedFamilies = new Set();\n    var updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(function (_ref) {\n      var family = _ref[0],\n          nextType = _ref[1];\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      var prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    }); // TODO: rename these fields to something more meaningful.\n\n    var update = {\n      updatedFamilies: updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies: staleFamilies // Families that will be remounted\n\n    };\n    helpersByRendererID.forEach(function (helpers) {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    var didError = false;\n    var firstError = null;\n    failedRoots.forEach(function (element, root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n    mountedRoots.forEach(function (root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n\n    if (didError) {\n      throw firstError;\n    }\n\n    return update;\n  }\n}\nfunction register(type, id) {\n  {\n    if (type === null) {\n      return;\n    }\n\n    if (typeof type !== 'function' && typeof type !== 'object') {\n      return;\n    } // This can happen in an edge case, e.g. if we register\n    // return value of a HOC but it returns a cached component.\n    // Ignore anything but the first registration for each type.\n\n\n    if (allFamiliesByType.has(type)) {\n      return;\n    } // Create family or remember to update it.\n    // None of this bookkeeping affects reconciliation\n    // until the first performReactRefresh() call above.\n\n\n    var family = allFamiliesByID.get(id);\n\n    if (family === undefined) {\n      family = {\n        current: type\n      };\n      allFamiliesByID.set(id, family);\n    } else {\n      pendingUpdates.push([family, type]);\n    }\n\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n    if (typeof type === 'object' && type !== null) {\n      switch (type.$$typeof) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + '$render');\n          break;\n\n        case REACT_MEMO_TYPE:\n          register(type.type, id + '$type');\n          break;\n      }\n    }\n  }\n}\nfunction setSignature(type, key) {\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n\n  {\n    allSignaturesByType.set(type, {\n      forceReset: forceReset,\n      ownKey: key,\n      fullKey: null,\n      getCustomHooks: getCustomHooks || function () {\n        return [];\n      }\n    });\n  }\n} // This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\n\nfunction collectCustomHooksForSignature(type) {\n  {\n    var signature = allSignaturesByType.get(type);\n\n    if (signature !== undefined) {\n      computeFullKey(signature);\n    }\n  }\n}\nfunction getFamilyByID(id) {\n  {\n    return allFamiliesByID.get(id);\n  }\n}\nfunction getFamilyByType(type) {\n  {\n    return allFamiliesByType.get(type);\n  }\n}\nfunction findAffectedHostInstances(families) {\n  {\n    var affectedInstances = new Set();\n    mountedRoots.forEach(function (root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n      instancesForRoot.forEach(function (inst) {\n        affectedInstances.add(inst);\n      });\n    });\n    return affectedInstances;\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  {\n    // For React Native, the global hook will be set up by require('react-devtools-core').\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\n    // For React Web, the global hook will be set up by the extension.\n    // This will also run before us.\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n    if (hook === undefined) {\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n      // Note that in this case it's important that renderer code runs *after* this method call.\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n      var nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        supportsFiber: true,\n        inject: function (injected) {\n          return nextID++;\n        },\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n        onCommitFiberUnmount: function () {}\n      };\n    } // Here, we just want to get a reference to scheduleRefresh.\n\n\n    var oldInject = hook.inject;\n\n    hook.inject = function (injected) {\n      var id = oldInject.apply(this, arguments);\n\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n\n      return id;\n    }; // We also want to track currently mounted roots.\n\n\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n      var helpers = helpersByRendererID.get(id);\n\n      if (helpers === undefined) {\n        return;\n      }\n\n      helpersByRoot.set(root, helpers);\n      var current = root.current;\n      var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n      // This logic is copy-pasted from similar logic in the DevTools backend.\n      // If this breaks with some refactoring, you'll want to update DevTools too.\n\n      if (alternate !== null) {\n        var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n        var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n        if (!wasMounted && isMounted) {\n          // Mount a new root.\n          mountedRoots.add(root);\n          failedRoots.delete(root);\n        } else if (wasMounted && isMounted) {// Update an existing root.\n          // This doesn't affect our mounted root Set.\n        } else if (wasMounted && !isMounted) {\n          // Unmount an existing root.\n          mountedRoots.delete(root);\n\n          if (didError) {\n            // We'll remount it on future edits.\n            // Remember what was rendered so we can restore it.\n            failedRoots.set(root, alternate.memoizedState.element);\n          } else {\n            helpersByRoot.delete(root);\n          }\n        } else if (!wasMounted && !isMounted) {\n          if (didError && !failedRoots.has(root)) {\n            // The root had an error during the initial mount.\n            // We can't read its last element from the memoized state\n            // because there was no previously committed alternate.\n            // Ideally, it would be nice if we had a way to extract\n            // the last attempted rendered element, but accessing the update queue\n            // would tie this package too closely to the reconciler version.\n            // So instead, we just set a flag.\n            // TODO: Maybe we could fix this as the same time as when we fix\n            // DevTools to not depend on `alternate.memoizedState.element`.\n            didSomeRootFailOnMount = true;\n          }\n        }\n      } else {\n        // Mount a new root.\n        mountedRoots.add(root);\n      }\n\n      return oldOnCommitFiberRoot.apply(this, arguments);\n    };\n  }\n}\nfunction hasUnrecoverableErrors() {\n  return didSomeRootFailOnMount;\n} // Exposed for testing.\n\nfunction _getMountedRootCount() {\n  {\n    return mountedRoots.size;\n  }\n} // This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Second call triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* First call specifies the signature: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\n\nfunction createSignatureFunctionForTransform() {\n  {\n    // We'll fill in the signature in two steps.\n    // First, we'll know the signature itself. This happens outside the component.\n    // Then, we'll know the references to custom Hooks. This happens inside the component.\n    // After that, the returned function will be a fast path no-op.\n    var status = 'needsSignature';\n    var savedType;\n    var hasCustomHooks;\n    return function (type, key, forceReset, getCustomHooks) {\n      switch (status) {\n        case 'needsSignature':\n          if (type !== undefined) {\n            // If we received an argument, this is the initial registration call.\n            savedType = type;\n            hasCustomHooks = typeof getCustomHooks === 'function';\n            setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.\n\n            status = 'needsCustomHooks';\n          }\n\n          break;\n\n        case 'needsCustomHooks':\n          if (hasCustomHooks) {\n            collectCustomHooksForSignature(savedType);\n          }\n\n          status = 'resolved';\n          break;\n\n        case 'resolved':\n          // Do nothing. Fast path for all future renders.\n          break;\n      }\n\n      return type;\n    };\n  }\n}\nfunction isLikelyComponentType(type) {\n  {\n    switch (typeof type) {\n      case 'function':\n        {\n          // First, deal with classes.\n          if (type.prototype != null) {\n            if (type.prototype.isReactComponent) {\n              // React class.\n              return true;\n            }\n\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n              // This looks like a class.\n              return false;\n            } // eslint-disable-next-line no-proto\n\n\n            if (type.prototype.__proto__ !== Object.prototype) {\n              // It has a superclass.\n              return false;\n            } // Pass through.\n            // This looks like a regular function with empty prototype.\n\n          } // For plain functions and arrows, use name as a heuristic.\n\n\n          var name = type.name || type.displayName;\n          return typeof name === 'string' && /^[A-Z]/.test(name);\n        }\n\n      case 'object':\n        {\n          if (type != null) {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_MEMO_TYPE:\n                // Definitely React components.\n                return true;\n\n              default:\n                return false;\n            }\n          }\n\n          return false;\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  }\n}\n\nvar ReactFreshRuntime = Object.freeze({\n\tperformReactRefresh: performReactRefresh,\n\tregister: register,\n\tsetSignature: setSignature,\n\tcollectCustomHooksForSignature: collectCustomHooksForSignature,\n\tgetFamilyByID: getFamilyByID,\n\tgetFamilyByType: getFamilyByType,\n\tfindAffectedHostInstances: findAffectedHostInstances,\n\tinjectIntoGlobalHook: injectIntoGlobalHook,\n\thasUnrecoverableErrors: hasUnrecoverableErrors,\n\t_getMountedRootCount: _getMountedRootCount,\n\tcreateSignatureFunctionForTransform: createSignatureFunctionForTransform,\n\tisLikelyComponentType: isLikelyComponentType\n});\n\n// This is hacky but makes it work with both Rollup and Jest.\n\n\nvar runtime = ReactFreshRuntime.default || ReactFreshRuntime;\n\nmodule.exports = runtime;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}